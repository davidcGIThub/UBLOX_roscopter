// Generated by gencpp from file ublox/Ephemeris.msg
// DO NOT EDIT!


#ifndef UBLOX_MESSAGE_EPHEMERIS_H
#define UBLOX_MESSAGE_EPHEMERIS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>

namespace ublox
{
template <class ContainerAllocator>
struct Ephemeris_
{
  typedef Ephemeris_<ContainerAllocator> Type;

  Ephemeris_()
    : header()
    , sat(0)
    , gnssID(0)
    , toe()
    , toc()
    , tow(0)
    , iodc(0)
    , iode(0)
    , week(0)
    , toes(0)
    , tocs(0)
    , health(0)
    , alert_flag(0)
    , anti_spoof(0)
    , code_on_L2(0)
    , ura(0)
    , L2_P_data_flag(0)
    , fit_interval_flag(0)
    , age_of_data_offset(0)
    , tgd()
    , af2(0.0)
    , af1(0.0)
    , af0(0.0)
    , m0(0.0)
    , delta_n(0.0)
    , ecc(0.0)
    , sqrta(0.0)
    , omega0(0.0)
    , i0(0.0)
    , w(0.0)
    , omegadot(0.0)
    , idot(0.0)
    , cuc(0.0)
    , cus(0.0)
    , crc(0.0)
    , crs(0.0)
    , cic(0.0)
    , cis(0.0)  {
      tgd.assign(0.0);
  }
  Ephemeris_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , sat(0)
    , gnssID(0)
    , toe()
    , toc()
    , tow(0)
    , iodc(0)
    , iode(0)
    , week(0)
    , toes(0)
    , tocs(0)
    , health(0)
    , alert_flag(0)
    , anti_spoof(0)
    , code_on_L2(0)
    , ura(0)
    , L2_P_data_flag(0)
    , fit_interval_flag(0)
    , age_of_data_offset(0)
    , tgd()
    , af2(0.0)
    , af1(0.0)
    , af0(0.0)
    , m0(0.0)
    , delta_n(0.0)
    , ecc(0.0)
    , sqrta(0.0)
    , omega0(0.0)
    , i0(0.0)
    , w(0.0)
    , omegadot(0.0)
    , idot(0.0)
    , cuc(0.0)
    , cus(0.0)
    , crc(0.0)
    , crs(0.0)
    , cic(0.0)
    , cis(0.0)  {
  (void)_alloc;
      tgd.assign(0.0);
  }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint8_t _sat_type;
  _sat_type sat;

   typedef uint8_t _gnssID_type;
  _gnssID_type gnssID;

   typedef ros::Time _toe_type;
  _toe_type toe;

   typedef ros::Time _toc_type;
  _toc_type toc;

   typedef uint32_t _tow_type;
  _tow_type tow;

   typedef uint16_t _iodc_type;
  _iodc_type iodc;

   typedef uint8_t _iode_type;
  _iode_type iode;

   typedef uint16_t _week_type;
  _week_type week;

   typedef uint32_t _toes_type;
  _toes_type toes;

   typedef uint32_t _tocs_type;
  _tocs_type tocs;

   typedef uint8_t _health_type;
  _health_type health;

   typedef uint8_t _alert_flag_type;
  _alert_flag_type alert_flag;

   typedef uint8_t _anti_spoof_type;
  _anti_spoof_type anti_spoof;

   typedef uint8_t _code_on_L2_type;
  _code_on_L2_type code_on_L2;

   typedef uint8_t _ura_type;
  _ura_type ura;

   typedef uint8_t _L2_P_data_flag_type;
  _L2_P_data_flag_type L2_P_data_flag;

   typedef uint8_t _fit_interval_flag_type;
  _fit_interval_flag_type fit_interval_flag;

   typedef uint16_t _age_of_data_offset_type;
  _age_of_data_offset_type age_of_data_offset;

   typedef boost::array<double, 4>  _tgd_type;
  _tgd_type tgd;

   typedef double _af2_type;
  _af2_type af2;

   typedef double _af1_type;
  _af1_type af1;

   typedef double _af0_type;
  _af0_type af0;

   typedef double _m0_type;
  _m0_type m0;

   typedef double _delta_n_type;
  _delta_n_type delta_n;

   typedef double _ecc_type;
  _ecc_type ecc;

   typedef double _sqrta_type;
  _sqrta_type sqrta;

   typedef double _omega0_type;
  _omega0_type omega0;

   typedef double _i0_type;
  _i0_type i0;

   typedef double _w_type;
  _w_type w;

   typedef double _omegadot_type;
  _omegadot_type omegadot;

   typedef double _idot_type;
  _idot_type idot;

   typedef double _cuc_type;
  _cuc_type cuc;

   typedef double _cus_type;
  _cus_type cus;

   typedef double _crc_type;
  _crc_type crc;

   typedef double _crs_type;
  _crs_type crs;

   typedef double _cic_type;
  _cic_type cic;

   typedef double _cis_type;
  _cis_type cis;



  enum {
    GNSSID_GPS = 0u,
    GNSSID_SBAS = 1u,
    GNSSID_GALILEO = 2u,
    GNSSID_BEIDOU = 3u,
    GNSSID_QZSS = 5u,
    GNSSID_GLONASS = 6u,
  };


  typedef boost::shared_ptr< ::ublox::Ephemeris_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::ublox::Ephemeris_<ContainerAllocator> const> ConstPtr;

}; // struct Ephemeris_

typedef ::ublox::Ephemeris_<std::allocator<void> > Ephemeris;

typedef boost::shared_ptr< ::ublox::Ephemeris > EphemerisPtr;
typedef boost::shared_ptr< ::ublox::Ephemeris const> EphemerisConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::ublox::Ephemeris_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::ublox::Ephemeris_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace ublox

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'std_msgs': ['/opt/ros/melodic/share/std_msgs/cmake/../msg'], 'ublox': ['/home/groot/roscop_ws/src/UBLOX_read/msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::ublox::Ephemeris_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::ublox::Ephemeris_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ublox::Ephemeris_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::ublox::Ephemeris_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ublox::Ephemeris_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::ublox::Ephemeris_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::ublox::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "db5d20325900ae20f8d218f3420f173b";
  }

  static const char* value(const ::ublox::Ephemeris_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xdb5d20325900ae20ULL;
  static const uint64_t static_value2 = 0xf8d218f3420f173bULL;
};

template<class ContainerAllocator>
struct DataType< ::ublox::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "ublox/Ephemeris";
  }

  static const char* value(const ::ublox::Ephemeris_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::ublox::Ephemeris_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n"
"\n"
"uint8 sat 					  # Satellite ID (within Constellation)\n"
"uint8 gnssID				  # Satellite ID (within Constellation)\n"
"\n"
"uint8 GNSSID_GPS = 0\n"
"uint8 GNSSID_SBAS = 1\n"
"uint8 GNSSID_GALILEO = 2\n"
"uint8 GNSSID_BEIDOU = 3\n"
"uint8 GNSSID_QZSS = 5\n"
"uint8 GNSSID_GLONASS = 6\n"
"\n"
"time  toe                     # reference time ephemeris (UTC Time inc. leap seconds)                         [s]\n"
"time  toc                     # reference time (clock)   (UTC Time inc. leap seconds)                         [s]\n"
"\n"
"uint32 tow                    # time of week in subframe1 the time of the leading bit edge of subframe 2      [s]\n"
"uint16 iodc                   # 10 bit issue of data (clock) 8 LSB bits will match the iode                   []\n"
"uint8  iode                   # 8 bit  issue of data (ephemeris)                                              []\n"
"uint16 week                   # 10 bit gps week 0-1023 (user must account for week rollover )                 [week]\n"
"uint32 toes                   # Time of ephemeris (seconds part)\n"
"uint32 tocs                   # Time of clock (seconds part)\n"
"uint8  health                 # 6 bit health parameter 0 if healthy unhealth othersize                        [0=healthy]\n"
"uint8  alert_flag             # 1 = URA may be worse than indicated                                           [0,1]\n"
"uint8  anti_spoof             # anti-spoof flag from 0=off 1=on                                               [0,1]\n"
"uint8  code_on_L2             # 0=reserved 1=P code on L2 2=C/A on L2                                         [0,1,2]\n"
"uint8  ura                    # User Range Accuracy lookup code 0 is excellent 15 is use at own risk          [0-15] see p. 83 GPSICD200C\n"
"uint8  L2_P_data_flag         # flag indicating if P is on L2 1=true                                          [0,1]\n"
"uint8  fit_interval_flag      # fit interval flag (four hour interval or longer) 0=4 fours 1=greater          [0,1]\n"
"uint16 age_of_data_offset     # age of data offset                                                            [s]\n"
"float64[4]   tgd              # group delay                                                                   [s]\n"
"float64   af2                 # polynomial clock correction coefficient (rate of clock drift)                 [s/s^2]\n"
"float64   af1                 # polynomial clock correction coefficient (clock drift)                         [s/s]\n"
"float64   af0                 # polynomial clock correction coefficient (clock bias)                          [s]\n"
"float64   m0                  # mean anomaly at reference time                                                [rad]\n"
"float64   delta_n             # mean motion difference from computed value                                    [rad/s]\n"
"float64   ecc                 # eccentricity                                                                  []\n"
"float64   sqrta               # square root of the semi-major axis                                            [m^(1/2)]\n"
"float64   omega0              # longitude of ascending node of orbit plane at weekly epoch                    [rad]\n"
"float64   i0                  # inclination angle at reference time                                           [rad]\n"
"float64   w                   # argument of perigee                                                           [rad]\n"
"float64   omegadot            # rate of right ascension                                                       [rad/s]\n"
"float64   idot                # rate of inclination angle                                                     [rad/s]\n"
"float64   cuc                 # amplitude of the cosine harmonic correction term to the argument of latitude  [rad]\n"
"float64   cus                 # amplitude of the sine harmonic correction term to the argument of latitude    [rad]\n"
"float64   crc                 # amplitude of the cosine harmonic correction term to the orbit radius          [m]\n"
"float64   crs                 # amplitude of the sine harmonic correction term to the orbit radius            [m]\n"
"float64   cic                 # amplitude of the cosine harmonic correction term to the angle of inclination  [rad]\n"
"float64   cis                 # amplitude of the sine harmonic correction term to the angle of inclination    [rad]\n"
"\n"
"\n"
"\n"
"================================================================================\n"
"MSG: std_msgs/Header\n"
"# Standard metadata for higher-level stamped data types.\n"
"# This is generally used to communicate timestamped data \n"
"# in a particular coordinate frame.\n"
"# \n"
"# sequence ID: consecutively increasing ID \n"
"uint32 seq\n"
"#Two-integer timestamp that is expressed as:\n"
"# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n"
"# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n"
"# time-handling sugar is provided by the client library\n"
"time stamp\n"
"#Frame this data is associated with\n"
"string frame_id\n"
;
  }

  static const char* value(const ::ublox::Ephemeris_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::ublox::Ephemeris_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.sat);
      stream.next(m.gnssID);
      stream.next(m.toe);
      stream.next(m.toc);
      stream.next(m.tow);
      stream.next(m.iodc);
      stream.next(m.iode);
      stream.next(m.week);
      stream.next(m.toes);
      stream.next(m.tocs);
      stream.next(m.health);
      stream.next(m.alert_flag);
      stream.next(m.anti_spoof);
      stream.next(m.code_on_L2);
      stream.next(m.ura);
      stream.next(m.L2_P_data_flag);
      stream.next(m.fit_interval_flag);
      stream.next(m.age_of_data_offset);
      stream.next(m.tgd);
      stream.next(m.af2);
      stream.next(m.af1);
      stream.next(m.af0);
      stream.next(m.m0);
      stream.next(m.delta_n);
      stream.next(m.ecc);
      stream.next(m.sqrta);
      stream.next(m.omega0);
      stream.next(m.i0);
      stream.next(m.w);
      stream.next(m.omegadot);
      stream.next(m.idot);
      stream.next(m.cuc);
      stream.next(m.cus);
      stream.next(m.crc);
      stream.next(m.crs);
      stream.next(m.cic);
      stream.next(m.cis);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct Ephemeris_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::ublox::Ephemeris_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::ublox::Ephemeris_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "sat: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.sat);
    s << indent << "gnssID: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.gnssID);
    s << indent << "toe: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.toe);
    s << indent << "toc: ";
    Printer<ros::Time>::stream(s, indent + "  ", v.toc);
    s << indent << "tow: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.tow);
    s << indent << "iodc: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.iodc);
    s << indent << "iode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.iode);
    s << indent << "week: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.week);
    s << indent << "toes: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.toes);
    s << indent << "tocs: ";
    Printer<uint32_t>::stream(s, indent + "  ", v.tocs);
    s << indent << "health: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.health);
    s << indent << "alert_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.alert_flag);
    s << indent << "anti_spoof: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.anti_spoof);
    s << indent << "code_on_L2: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.code_on_L2);
    s << indent << "ura: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ura);
    s << indent << "L2_P_data_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.L2_P_data_flag);
    s << indent << "fit_interval_flag: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.fit_interval_flag);
    s << indent << "age_of_data_offset: ";
    Printer<uint16_t>::stream(s, indent + "  ", v.age_of_data_offset);
    s << indent << "tgd[]" << std::endl;
    for (size_t i = 0; i < v.tgd.size(); ++i)
    {
      s << indent << "  tgd[" << i << "]: ";
      Printer<double>::stream(s, indent + "  ", v.tgd[i]);
    }
    s << indent << "af2: ";
    Printer<double>::stream(s, indent + "  ", v.af2);
    s << indent << "af1: ";
    Printer<double>::stream(s, indent + "  ", v.af1);
    s << indent << "af0: ";
    Printer<double>::stream(s, indent + "  ", v.af0);
    s << indent << "m0: ";
    Printer<double>::stream(s, indent + "  ", v.m0);
    s << indent << "delta_n: ";
    Printer<double>::stream(s, indent + "  ", v.delta_n);
    s << indent << "ecc: ";
    Printer<double>::stream(s, indent + "  ", v.ecc);
    s << indent << "sqrta: ";
    Printer<double>::stream(s, indent + "  ", v.sqrta);
    s << indent << "omega0: ";
    Printer<double>::stream(s, indent + "  ", v.omega0);
    s << indent << "i0: ";
    Printer<double>::stream(s, indent + "  ", v.i0);
    s << indent << "w: ";
    Printer<double>::stream(s, indent + "  ", v.w);
    s << indent << "omegadot: ";
    Printer<double>::stream(s, indent + "  ", v.omegadot);
    s << indent << "idot: ";
    Printer<double>::stream(s, indent + "  ", v.idot);
    s << indent << "cuc: ";
    Printer<double>::stream(s, indent + "  ", v.cuc);
    s << indent << "cus: ";
    Printer<double>::stream(s, indent + "  ", v.cus);
    s << indent << "crc: ";
    Printer<double>::stream(s, indent + "  ", v.crc);
    s << indent << "crs: ";
    Printer<double>::stream(s, indent + "  ", v.crs);
    s << indent << "cic: ";
    Printer<double>::stream(s, indent + "  ", v.cic);
    s << indent << "cis: ";
    Printer<double>::stream(s, indent + "  ", v.cis);
  }
};

} // namespace message_operations
} // namespace ros

#endif // UBLOX_MESSAGE_EPHEMERIS_H
